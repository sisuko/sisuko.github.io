<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Homenaje a Larra - GLB Posición Corregida</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #f0f0f0; }
        canvas { display: block; cursor: pointer; }
        .info { /* Estilos Info sin cambios */ }
        #zorrillaAudio { display: none; }
    </style>
</head>
<body>

<div class="info">
    Entierro de Larra - GLB Posición Corregida.<br>
    Haz clic sobre Zorrilla (modelo) para escuchar.<br>
    Usa el ratón para mover la cámara.
</div>

<!-- Elemento de Audio (sin cambios) -->
<audio id="zorrillaAudio" src="zorrilla_poema.mp3" preload="auto"></audio>
<!-- ¡¡¡ IMPORTANTE: Reemplaza "zorrilla_poema.mp3" con tu archivo de sonido !!! -->

<!-- Import Map y Shims -->
<script async src="https://unpkg.com/es-module-shims@1.6.3/dist/es-module-shims.js"></script>
<script type="importmap">
  {
    "imports": {
      "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
      "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
    }
  }
</script>

<!-- Script Principal (Módulo) -->
<script type="module">

    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
    import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';

    // --- Configuración Básica, Iluminación, Suelo, Tumba, Niebla (SIN CAMBIOS) ---
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x87CEEB); scene.fog = new THREE.Fog(0x87CEEB, 30, 150);
    const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 250);
    camera.position.set(2, 10, 20); camera.lookAt(0, 1, 0);
    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.shadowMap.enabled = true; renderer.shadowMap.type = THREE.PCFSoftShadowMap;
    document.body.appendChild(renderer.domElement);
    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true; controls.target.set(0, 1.5, 0); controls.maxDistance = 120;
    const ambientLight = new THREE.AmbientLight(0x606060); scene.add(ambientLight);
    const directionalLight = new THREE.DirectionalLight(0xffffff, 0.9); directionalLight.position.set(20, 40, 30); directionalLight.castShadow = true; /* Sombra config */ directionalLight.shadow.mapSize.width = 1024; directionalLight.shadow.mapSize.height = 1024; directionalLight.shadow.camera.near = 0.5; directionalLight.shadow.camera.far = 120; directionalLight.shadow.camera.left = -70; directionalLight.shadow.camera.right = 70; directionalLight.shadow.camera.top = 70; directionalLight.shadow.camera.bottom = -70; scene.add(directionalLight);
    const groundGeometry = new THREE.PlaneGeometry(200, 200); const groundMaterial = new THREE.MeshStandardMaterial({ color: 0x556B2F, roughness: 0.9, metalness: 0.1 }); const ground = new THREE.Mesh(groundGeometry, groundMaterial); ground.rotation.x = -Math.PI / 2; ground.receiveShadow = true; scene.add(ground);
    const graveGeometry = new THREE.BoxGeometry(3, 0.5, 1.5); const graveMaterial = new THREE.MeshStandardMaterial({ color: 0x666666 }); const grave = new THREE.Mesh(graveGeometry, graveMaterial); grave.position.set(0, 0.25, 0); grave.castShadow = true; grave.receiveShadow = true; scene.add(grave);

    // --- FUNCIÓN PARA CREAR PERSONAS (ASISTENTES - SIN CAMBIOS) ---
    function createPerson(options = {}) { /* ... Mismo código createPerson para asistentes ... */ const defaults={isZorrilla:!1,pose:"standing",minHeight:1.5,maxHeight:1.9,skinToneBase:[.8,.6,.4],skinToneVariance:.1,clothingColorBase:[.1,.1,.1],clothingColorVariance:.1},config={...defaults,...options},personGroup=new THREE.Group,height=config.minHeight+Math.random()*(config.maxHeight-config.minHeight),headRatio=.15,torsoRatio=.35,legRatio=1-headRatio-torsoRatio,headRadius=height*headRatio/2,torsoHeight=height*torsoRatio,legHeight=height*legRatio,bodyWidth=height*.2*(.8+Math.random()*.4),armWidth=bodyWidth*.25,legWidth=bodyWidth*.3,skinTone=new THREE.Color;skinTone.setRGB(config.skinToneBase[0]+(Math.random()-.5)*2*config.skinToneVariance,config.skinToneBase[1]+(Math.random()-.5)*2*config.skinToneVariance,config.skinToneBase[2]+(Math.random()-.5)*2*config.skinToneVariance);const clothingColor1=new THREE.Color;clothingColor1.setRGB(config.clothingColorBase[0]+Math.random()*config.clothingColorVariance,config.clothingColorBase[1]+Math.random()*config.clothingColorVariance,config.clothingColorBase[2]+Math.random()*config.clothingColorVariance);const clothingColor2=new THREE.Color;clothingColor2.setRGB(config.clothingColorBase[0]+Math.random()*config.clothingColorVariance,config.clothingColorBase[1]+Math.random()*config.clothingColorVariance,config.clothingColorBase[2]+Math.random()*config.clothingColorVariance);const skinMaterial=new THREE.MeshStandardMaterial({color:skinTone,roughness:.8}),clothingMaterial1=new THREE.MeshStandardMaterial({color:clothingColor1,roughness:.85,metalness:.1}),clothingMaterial2=new THREE.MeshStandardMaterial({color:clothingColor2,roughness:.85,metalness:.1}),headGeometry=new THREE.SphereGeometry(headRadius,12,10),torsoGeometry=new THREE.BoxGeometry(bodyWidth,torsoHeight,bodyWidth*.7),armGeometry=new THREE.CylinderGeometry(armWidth/2,armWidth/2,torsoHeight*.9,8),legGeometry=new THREE.CylinderGeometry(legWidth/2,legWidth/2,legHeight,8),head=new THREE.Mesh(headGeometry,skinMaterial);head.position.y=legHeight+torsoHeight+headRadius*.8,head.castShadow=!0,head.receiveShadow=!0,personGroup.add(head);const torso=new THREE.Mesh(torsoGeometry,clothingMaterial1);torso.position.y=legHeight+torsoHeight/2,torso.castShadow=!0,torso.receiveShadow=!0,personGroup.add(torso);const legL=new THREE.Mesh(legGeometry,clothingMaterial2);legL.position.set(-bodyWidth/3.5,legHeight/2,0),legL.castShadow=!0,legL.receiveShadow=!0,personGroup.add(legL);const legR=new THREE.Mesh(legGeometry,clothingMaterial2);legR.position.set(bodyWidth/3.5,legHeight/2,0),legR.castShadow=!0,legR.receiveShadow=!0,personGroup.add(legR);const armL=new THREE.Mesh(armGeometry,clothingMaterial1),armR=new THREE.Mesh(armGeometry,clothingMaterial1);armL.castShadow=!0,armL.receiveShadow=!0,armR.castShadow=!0,armR.receiveShadow=!0,personGroup.add(armL),personGroup.add(armR),armL.position.set(-bodyWidth/2-armWidth/2,legHeight+torsoHeight*.55,0),armR.position.set(bodyWidth/2+armWidth/2,legHeight+torsoHeight*.55,0),armL.rotation.z=THREE.MathUtils.degToRad(10)+(Math.random()-.5)*.2,armR.rotation.z=THREE.MathUtils.degToRad(-10)+(Math.random()-.5)*.2;return personGroup }


    // --- CARGAR MODELO ZORRILLA (con Ajuste Automático de Altura) ---
    let zorrillaObject;
    const loader = new GLTFLoader();
    const modelPath = 'zorrilla_modelo.glb'; // <-- Revisa esta ruta

    console.log(`Intentando cargar modelo desde: ${modelPath}`);

    loader.load(
        modelPath,
        function ( gltf ) { // Éxito
            console.log("Modelo GLB cargado:", gltf);

            const wrapperGroup = new THREE.Group();
            wrapperGroup.name = "ZorrillaWrapper";
            wrapperGroup.add( gltf.scene ); // Añadir modelo al wrapper PRIMERO

            // Aplicar escala DESEADA al wrapper
            const desiredScale = 1.0; // <-- Ajusta esta escala si es necesario
            wrapperGroup.scale.set(desiredScale, desiredScale, desiredScale);

            // *** CALCULAR BOUNDING BOX Y AJUSTAR ALTURA ***
            // Es importante hacerlo DESPUÉS de añadir al wrapper y escalar
            const box = new THREE.Box3().setFromObject( wrapperGroup );
            const modelMinY = box.min.y; // Punto más bajo del modelo (relativo al origen del wrapper)
            const verticalShift = -modelMinY; // Cantidad a subir para que min.y sea 0

            console.log(`Bounding Box min Y: ${modelMinY}, Ajuste vertical necesario: ${verticalShift}`);

            // Aplicar posición X, Z y el ajuste Y calculado AL WRAPPER
            wrapperGroup.position.set(
                0,             // Posición X deseada
                verticalShift, // Posición Y calculada para tocar el suelo
                2.5            // Posición Z deseada
            );
            // wrapperGroup.rotation.y = Math.PI; // Rotar si es necesario

            // Asignar y añadir a la escena
            zorrillaObject = wrapperGroup;
            scene.add( zorrillaObject );
            console.log("Wrapper de Zorrilla añadido y posicionado en Y=", verticalShift);

            // Activar sombras (sin cambios)
            gltf.scene.traverse( function ( child ) {
                if ( child.isMesh ) {
                    child.castShadow = true;
                    child.receiveShadow = true;
                }
            });

        },
        function ( xhr ) { /* Progreso (sin cambios) */ },
        function ( error ) { // Error (sin cambios, crea fallback)
            console.error( '¡ERROR AL CARGAR EL MODELO GLB!', error );
            console.log("Creando figura de fallback (cubo rojo) para Zorrilla.");
            const fallbackGeometry = new THREE.BoxGeometry(0.8, 1.8, 0.8);
            const fallbackMaterial = new THREE.MeshStandardMaterial({ color: 0xff0000 });
            zorrillaObject = new THREE.Mesh(fallbackGeometry, fallbackMaterial);
            zorrillaObject.position.set(0, 1.8 / 2, 2.5);
            zorrillaObject.name = "ZorrillaFallbackCube";
            zorrillaObject.castShadow = true; zorrillaObject.receiveShadow = true;
            scene.add(zorrillaObject);
        }
    );


    // --- Crear Asistentes (SIN CAMBIOS) ---
    const numAttendees = 35; const crowdRadius = 18; const innerRadius = 5;
    for (let i = 0; i < numAttendees; i++) { const attendee = createPerson(); const angle = Math.random() * Math.PI * 2; const radius = innerRadius + Math.random() * (crowdRadius - innerRadius); const x = Math.cos(angle) * radius; const z = Math.sin(angle) * radius; attendee.position.set(x, 0, z); const randomLookX = 0 + (Math.random() - 0.5) * 2; const randomLookZ = 2.5 + (Math.random() - 0.5) * 2; attendee.lookAt(randomLookX, attendee.position.y + 1.6, randomLookZ); scene.add(attendee); }


    // --- Cipreses (Función y Bucle SIN CAMBIOS) ---
    function createCypress() { /* ... */ return new THREE.Mesh(/* ... */); } // Código igual
    const numCypresses = 45; const treeAreaRadius = 80; const treeInnerRadius = 15;
    for (let i = 0; i < numCypresses; i++) { /* Código igual */ const cypress = createCypress(); let x, z, validPosition; do { const angle = Math.random() * Math.PI * 2; const radius = treeInnerRadius + Math.random() * (treeAreaRadius - treeInnerRadius); x = Math.cos(angle) * radius; z = Math.sin(angle) * radius; validPosition = (x*x + z*z) > (innerRadius*innerRadius + 5); } while (!validPosition); cypress.position.x = x; cypress.position.z = z; scene.add(cypress); }


    // --- Lápidas (Función y Bucle SIN CAMBIOS) ---
    function createGravestone() { /* ... */ return new THREE.Mesh(/* ... */); } // Código igual
    const numGravestones = 70; const stoneAreaRadius = 75; const stoneInnerRadius = 10;
    for (let i = 0; i < numGravestones; i++) { /* Código igual */ const gravestone = createGravestone(); let x, z, validPosition; do { const angle = Math.random() * Math.PI * 2; const radius = stoneInnerRadius + Math.random() * (stoneAreaRadius - stoneInnerRadius); x = Math.cos(angle) * radius; z = Math.sin(angle) * radius; validPosition = (x*x + z*z) > (innerRadius*innerRadius + 3); } while (!validPosition); gravestone.position.x = x; gravestone.position.z = z; gravestone.rotation.y = (Math.random() - 0.5) * 0.5; scene.add(gravestone); }


    // --- Paredes del Cementerio (SIN CAMBIOS) ---
    /* ... Mismo código para añadir paredes ... */ const wallDistance = 90; const wallLength = 180; const wallHeight = 3.5; const wallDepth = 0.5; const wallMaterial = new THREE.MeshStandardMaterial({ color: 0x888877, roughness: 0.9, metalness: 0.05 }); const wallGeometry = new THREE.BoxGeometry(wallLength, wallHeight, wallDepth); const wallZpos = new THREE.Mesh(wallGeometry, wallMaterial); wallZpos.position.set(0, wallHeight / 2, wallDistance); wallZpos.castShadow = true; wallZpos.receiveShadow = true; scene.add(wallZpos); const wallZneg = new THREE.Mesh(wallGeometry, wallMaterial); wallZneg.position.set(0, wallHeight / 2, -wallDistance); wallZneg.castShadow = true; wallZneg.receiveShadow = true; scene.add(wallZneg); const wallXpos = new THREE.Mesh(wallGeometry, wallMaterial); wallXpos.position.set(wallDistance, wallHeight / 2, 0); wallXpos.rotation.y = Math.PI / 2; wallXpos.castShadow = true; wallXpos.receiveShadow = true; scene.add(wallXpos); const wallXneg = new THREE.Mesh(wallGeometry, wallMaterial); wallXneg.position.set(-wallDistance, wallHeight / 2, 0); wallXneg.rotation.y = Math.PI / 2; wallXneg.castShadow = true; wallXneg.receiveShadow = true; scene.add(wallXneg);


    // --- LÓGICA DE RAYCASTING Y SONIDO (SIN CAMBIOS) ---
    const raycaster = new THREE.Raycaster(); const mouse = new THREE.Vector2(); const zorrillaAudio = document.getElementById('zorrillaAudio');
    function onPointerDown( event ) { if (!zorrillaObject) { console.log("Objeto Zorrilla (wrapper/fallback) aún no definido."); return; } mouse.x = ( event.clientX / window.innerWidth ) * 2 - 1; mouse.y = - ( event.clientY / window.innerHeight ) * 2 + 1; raycaster.setFromCamera( mouse, camera ); const intersects = raycaster.intersectObject( zorrillaObject, true ); if ( intersects.length > 0 ) { console.log(`Clic detectado en: ${zorrillaObject.name}`); if (zorrillaAudio) { zorrillaAudio.currentTime = 0; zorrillaAudio.play().catch(error => console.error("Error al reproducir audio:", error)); } else { console.error("Elemento de audio 'zorrillaAudio' no encontrado."); } } }
    renderer.domElement.addEventListener( 'pointerdown', onPointerDown, false );


    // --- Animación y Redimensionamiento (SIN CAMBIOS) ---
    function animate() { requestAnimationFrame(animate); controls.update(); renderer.render(scene, camera); }
    window.addEventListener('resize', () => { camera.aspect = window.innerWidth / window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); });
    animate();

</script>

</body>
</html>